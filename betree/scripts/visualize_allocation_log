#!/usr/bin/env python3

import functools
from math import floor
import os
import struct
import sys

import matplotlib.pyplot as plt
from matplotlib.animation import FFMpegWriter
from matplotlib.widgets import Slider
import numpy as np
from tqdm import tqdm

# Constants to get relevant information from the disk_offset
MASK_STORAGE_CLASS = ((1 << 2) - 1) << (10 + 52)
MASK_DISK_ID = ((1 << 10) - 1) << 52
MASK_OFFSET = (1 << 52) - 1
SEGMENT_SIZE_LOG_2 = 18
SEGMENT_SIZE = 1 << SEGMENT_SIZE_LOG_2
SEGMENT_SIZE_MASK = SEGMENT_SIZE - 1
# This is the amount of bytes one (de-)allocation has in the log
SIZE_PER_ALLOCATION = 13


def parse_disk_offset(offset: int) -> tuple[int, int, int, int]:
    storage_class = (offset & MASK_STORAGE_CLASS) >> (52 + 10)
    disk_id = (offset & MASK_DISK_ID) >> 52
    block_offset = offset & MASK_OFFSET
    segment_id = block_offset & ~SEGMENT_SIZE_MASK
    return storage_class, disk_id, segment_id, block_offset


class Config:
    num_storage_ids: int
    disks_per_storage_id: list[int]
    blocks_per_disk: list[list[int]]
    blocks_per_segment: int

    def __init__(self, num_storage_ids: int, disks_per_storage_id: list[int],
                 blocks_per_disk: list[list[int]], blocks_per_segment: int):
        self.num_storage_ids = num_storage_ids
        self.disks_per_storage_id = disks_per_storage_id
        self.blocks_per_disk = blocks_per_disk
        self.blocks_per_segment = blocks_per_segment

    def __str__(self) -> str:
        return f"num_storage_ids: {self.num_storage_ids}, \
        disks_per_class: {self.disks_per_storage_id}, \
        blocks_per_disk: {self.blocks_per_disk}, \
        blocks_per_segment: {self.blocks_per_segment}"

    def blocks_global(self) -> int:
        return sum(self.blocks_of_storage_id(storage_id) for
                   storage_id in range(self.num_storage_ids))

    def disks_of_storage_id(self, storage_id: int) -> int:
        return self.disks_per_storage_id[storage_id]

    def blocks_of_storage_id(self, storage_id: int) -> int:
        return sum(self.blocks_of_disk(storage_id, disk_id) for
                   disk_id in range(self.disks_of_storage_id(storage_id)))

    def blocks_of_disk(self, storage_id: int, disk_id: int) -> int:
        return self.blocks_per_disk[storage_id][disk_id]

    def is_valid_storage(self, storage_id: int) -> bool:
        if storage_id >= self.num_storage_ids or storage_id < 0:
            return False
        return True

    def is_valid_disk(self, storage_id: int, disk_id: int) -> bool:
        if not self.is_valid_storage(storage_id):
            return False

        if disk_id >= self.disks_of_storage_id(storage_id) or disk_id < 0:
            return False

        return True


def parse_header(log_file: str) -> Config:
    """Parses the global header of the allocation log file."""

    with open(log_file, "rb") as f:
        num_classes = struct.unpack("<B", f.read(1))[0]
        disks_per_class = []
        for _ in range(num_classes):
            disks_per_class.append(struct.unpack("<H", f.read(2))[0])

        blocks_per_disk = []
        for i in range(num_classes):
            blocks_per_disk.append([])
            for _ in range(disks_per_class[i]):
                blocks_per_disk[i].append(struct.unpack("<Q", f.read(8))[0])

        blocks_per_segment = struct.unpack("<Q", f.read(8))[0]

    return Config(num_classes, disks_per_class, blocks_per_disk, blocks_per_segment)


def remaining_bytes(file_pointer) -> int:
    """Returns the remaining bytes in a file from the current position of the file pointer."""
    current_position = file_pointer.tell()
    file_pointer.seek(0, os.SEEK_END)  # Go to the end of the file
    end_position = file_pointer.tell()
    # Return to the original position
    file_pointer.seek(current_position, os.SEEK_SET)
    return end_position - current_position


class GlobalBitMap:
    config: Config
    # NOTE: the bitmap is stored as packed bits and has to be unpacked for accurate plotting,
    # based on some experimentation storing unpacked (and using 8x more memory) isn't worth it for
    # faster plotting
    # dict [tuple[storage, disk, segment], list[tuple[time, bitmap]]]
    bitmap: dict[tuple[int, int, int], list[tuple[int, np.ndarray]]]
    log_file: str
    time: int = 0
    disk_begins: list[list] = []
    # storage_id[timestep[tuple[frag, total_free, largest_free]]]
    storage_frag: list[list[tuple[float, int, int]]] = []
    # timestep[tuple[frag, total_free, largest_free]]
    global_frag: list[tuple[float, int, int]] = []

    def __init__(self, log_file: str, config: Config):
        self.config = config
        self.log_file = log_file
        self._initialize_bitmap()
        self._initialize_begins()
        self._build_global_bitmap()
        self._initialize_frag()
        self._build_fragmentation()

    def __str__(self) -> str:
        return f"Log_file: {self.log_file}\nTime: {self.time}\n" + \
            f"Config: {self.config}\nDisk_begins: {self.disk_begins}\n"

    def _initialize_bitmap(self):
        self.bitmap = {}
        for storage_id in range(self.config.num_storage_ids):
            for disk_id in range(self.config.disks_of_storage_id(storage_id)):
                used_blocks = 0
                blocks_in_disk = self.config.blocks_of_disk(
                    storage_id, disk_id)
                while used_blocks < blocks_in_disk:
                    segment_size = min(self.config.blocks_per_segment, blocks_in_disk - used_blocks)

                    bitmap = np.packbits(np.zeros(segment_size, dtype=bool))
                    self.bitmap[(storage_id, disk_id, used_blocks)] = [(0, bitmap)]
                    used_blocks += segment_size

    def _initialize_begins(self):
        for storage_id in range(self.config.num_storage_ids):
            self.disk_begins.append([])
            offset = 0
            for disk_id in range(self.config.disks_of_storage_id(storage_id)):
                self.disk_begins[storage_id].append(offset)
                offset += self.config.blocks_of_disk(storage_id, disk_id)

    def _build_global_bitmap(self):
        """Builds a global bitmap representation for each time step."""
        with open(self.log_file, "rb") as f:
            # Skip the global header (already parsed)
            header_length = (1
                             + 2 * self.config.num_storage_ids
                             + 8 * sum(self.config.disks_per_storage_id) + 8)
            f.seek(header_length)

            timesteps = remaining_bytes(f) // SIZE_PER_ALLOCATION

            for _ in tqdm(range(timesteps), desc="Building Global Bitmap"):
                # Read Allocation
                try:
                    op_type = struct.unpack("<B", f.read(1))[0]
                    offset = struct.unpack("<Q", f.read(8))[0]
                    num_blocks = struct.unpack("<L", f.read(4))[0]
                except struct.error:
                    break  # End of file

                self.time += 1

                storage_id, disk_id, segment_id, block_offset = parse_disk_offset(offset)
                segment_offset = block_offset % self.config.blocks_per_segment

                # Update the bitmap at (storage_id, disk_id, segment_id)
                # with op_type at block_offset and size
                last_entry = self.bitmap[(storage_id, disk_id, segment_id)][-1]
                new_bitmap = np.unpackbits(last_entry[1]).copy()
                new_bitmap[segment_offset: segment_offset + num_blocks] = op_type
                new_bitmap = np.packbits(new_bitmap)
                self.bitmap[(storage_id, disk_id, segment_id)].append((self.time, new_bitmap))

    def _get_valid_time(self, time: int = None) -> int:
        if time is None or time > self.time:
            return self.time
        if time < 0:
            return 0
        return time

    def _initialize_frag(self):
        for storage_id in range(self.config.num_storage_ids):
            largest_size = 0
            total_size = 0
            for disk_id in range(self.config.disks_of_storage_id(storage_id)):
                blocks = self.config.blocks_of_disk(storage_id, disk_id)
                largest_size = max(largest_size, blocks)
                total_size += blocks

            self.storage_frag.append([])
            frag = calculate_fragmentation(largest_size, total_size)
            self.storage_frag[storage_id].append((frag, total_size, largest_size))

    def _build_fragmentation(self):
        for timestep in tqdm(range(1, self.time), "Calculating Fragmentation Data"):
            largest_free = 0
            total_free = 0
            for storage_id in range(self.config.num_storage_ids):
                frag, total, largest = self.calculate_fragmentation_storage(storage_id, timestep)
                self.storage_frag[storage_id].append((frag, total, largest))
                largest_free = max(largest, largest_free)
                total_free += total

            frag = calculate_fragmentation(total_free, largest_free)
            self.global_frag.append((frag, total_free, largest_free))

    def calculate_fragmentation(self, time: int = None) -> tuple[float, int, int]:
        time = self._get_valid_time(time)

        largest_free = 0
        total_free = 0
        for storage_id in range(self.config.num_storage_ids):
            _, total, largest = self.calculate_fragmentation_storage(storage_id, time)
            largest_free = max(largest, largest_free)
            total_free += total

        return calculate_fragmentation(total_free, largest_free), total_free, largest_free

    def calculate_fragmentation_storage(self, storage_id: int, time: int = None) -> tuple[float, int, int]:
        time = self._get_valid_time(time)
        if not self.config.is_valid_storage(storage_id):
            return (0.0, 0, 0)

        largest_free = 0
        total_free = 0
        for disk_id in range(self.config.disks_of_storage_id(storage_id)):
            _, total, largest = self.calculate_fragmentation_disk(storage_id, disk_id, time)
            largest_free = max(largest, largest_free)
            total_free += total

        return calculate_fragmentation(total_free, largest_free), total_free, largest_free

    def calculate_fragmentation_disk(self, storage_id: int, disk_id: int, time: int = None) -> tuple[float, int, int]:
        time = self._get_valid_time(time)
        if not self.config.is_valid_disk(storage_id, disk_id):
            return (0.0, 0, 0)

        entries = filter(lambda k: k[0] == storage_id and k[1] == disk_id, self.bitmap)

        largest_free = 0
        total_free = 0
        for entry in entries:
            time, bitmap_at_time = self._binary_search_time(time, entry)

            segment_bitmap = np.unpackbits(bitmap_at_time)
            _, total, largest = fragmentation_of_bitmap(segment_bitmap)
            largest_free = max(largest, largest_free)
            total_free += total

        return calculate_fragmentation(total_free, largest_free), total_free, largest_free

    # Get the global bitmap at time. If no time is provided return the bitmap
    # of the last timestep.
    def get(self, output_bitmap: np.array, time: int = None) -> int:
        time = self._get_valid_time(time)

        start = 0
        for storage_id in range(self.config.num_storage_ids):
            start += self.get_storage(output_bitmap[start:], storage_id, time)

        return start

    def get_bitmap(self, time: int = None) -> np.array:
        num_blocks = self.config.blocks_global()
        bitmap = np.zeros(num_blocks, dtype=np.uint8)
        self.get(bitmap, time)

        return bitmap

    # Get the bitmap of a storage id at time. If no time is provided return the
    # bitmap of the last timestep.
    # If it doesn't match with the config throw an errer
    def get_storage(self, output_bitmap: np.array, storage_id: int, time: int = None) -> int:
        time = self._get_valid_time(time)
        if not self.config.is_valid_storage(storage_id):
            return 0

        start = 0
        for disk_id in range(self.config.disks_of_storage_id(storage_id)):
            start += self.get_disk(output_bitmap[start:], storage_id, disk_id, time)

        return start

    def get_storage_bitmap(self, storage_id: int, time: int = None) -> np.array:
        num_blocks = self.config.blocks_of_storage_id(storage_id)
        bitmap = np.zeros(num_blocks, dtype=np.uint8)
        self.get_storage(bitmap, storage_id, time)
        return bitmap

    # Get the bitmap of a disk id at time. If no time is provided return the
    # bitmap of the last timestep.
    # If it doesn't match with the config throw an errer
    def get_disk(self, output_bitmap: np.array, storage_id: int, disk_id: int, time: int = None) -> int:
        time = self._get_valid_time(time)
        if not self.config.is_valid_disk(storage_id, disk_id):
            return 0

        blocks_per_segment = self.config.blocks_per_segment
        entries = filter(lambda k: k[0] == storage_id and k[1] == disk_id, self.bitmap)

        for entry in entries:
            segment_id = entry[2]
            time, bitmap_at_time = self._binary_search_time(time, entry)
            end = min(segment_id + blocks_per_segment, self.config.blocks_of_disk(entry[0], entry[1]))

            output_bitmap[segment_id:end] = np.unpackbits(bitmap_at_time)

        return end

    def get_disk_bitmap(self, storage_id: int, disk_id: int, time: int = None) -> np.array:
        num_blocks = self.config.blocks_of_disk(storage_id, disk_id)
        bitmap = np.zeros(num_blocks, dtype=np.uint8)
        self.get_disk(bitmap, storage_id, disk_id, time)
        return bitmap

    @functools.lru_cache(1024)
    def _binary_search_time(self, time: int, entry: (int, int, int)) -> tuple[int, np.array]:
        bitmaps = self.bitmap[entry]
        left = 0
        right = len(bitmaps) - 1
        result = None
        while left <= right:
            middle = floor((left + right) / 2)
            if bitmaps[middle][0] == time:
                return bitmaps[middle]
            elif bitmaps[middle][0] < time:
                result = bitmaps[middle]
                left = middle + 1
            else:
                right = middle - 1

        return result

    def plot(self):
        """Plots the bitmap with an interactive slider for timestamp selection and checkboxes for storage toggling."""
        form = [
            [".", ".", ".", ".", ".", "."],
            [".", "storage_0", "storage_1", "storage_2", "storage_3", "."],
            [".", "frag_0", "frag_1", "frag_2", "frag_3", "."],
            [".", "frag_global", "frag_global", "frag_global", "frag_global", "."],
            [".", "slider", "slider", "slider", "slider", "."],
            [".", ".", ".", ".", ".", "."],
        ]
        gs_kw = {"width_ratios": [0.03, 1, 1, 1, 1, 0.03],
                 "height_ratios": [0.03, 3, 1, 1, 0.1, 0.03]}
        fig, axd = plt.subplot_mosaic(form, gridspec_kw=gs_kw, layout="constrained")
        fig.set_size_inches(16, 9)
        fig.set_dpi(1920 / 16)

        vlines = self._plot_fragmentation(axd)

        ims = []
        # Initial plot
        for storage_id in range(self.config.num_storage_ids):
            name = f"storage_{storage_id}"
            # NOTE: We first have to plot a later timestamp to initialize the size of the axes else
            # the bitmaps of other storages aren't correctly drawn. We manually set the starting
            # time to 1 shortly before plotting.
            storage_bitmap = self.get_storage_bitmap(storage_id)
            resized_bitmap = None
            if len(storage_bitmap) != 0:
                colored_bitmap = self._color_disks(storage_bitmap, storage_id)
                resized_bitmap = reshape_to_axes(colored_bitmap, axd[name], fig)
            else:
                storage_ax = axd[f"storage_{storage_id}"]
                kw = {"ha": "center", "va": "center", "fontsize": 12, "color": "darkgrey"}
                storage_ax.text(0.5, 0.5, "[Empty]", transform=storage_ax.transAxes, **kw)

            ims.append({})
            ims[storage_id]["storage_bitmap"] = storage_bitmap
            ims[storage_id]["resized_bitmap"] = resized_bitmap
            ims[storage_id]["im"] = axd[name].imshow(resized_bitmap, aspect="auto", interpolation=None)
            axd[name].set_title(f"Storage {storage_id}")
            axd[name].set_xlabel("Block")
            axd[name].set_ylabel("Block")
            axd[name].set_xticks([])
            axd[name].set_yticks([])
            bbox = axd[name].get_window_extent().transformed(fig.dpi_scale_trans.inverted())
            ims[storage_id]["width"] = bbox.width
            ims[storage_id]["height"] = bbox.height

        # Create the format specifier with appropriate spacing to prevent moving of axes
        max_digits = len(str(self.time - 1))
        valfmt = f"%{max_digits}d"
        slider = Slider(
            axd["slider"],
            "",
            0,
            self.time - 1,
            valinit=self.time - 1,
            valstep=1,
            valfmt=valfmt
        )

        def update(val):
            timestep = int(val)
            if timestep > self.time - 1:
                slider.set_val(self.time - 1)
                return

            for storage_id in range(self.config.num_storage_ids):
                self.get_storage(ims[storage_id]["storage_bitmap"], storage_id, timestep)
                if len(ims[storage_id]["storage_bitmap"]) != 0:
                    resized_bitmap = reshape_to_close_aspect(
                        ims[storage_id]["storage_bitmap"],
                        ims[storage_id]["width"],
                        ims[storage_id]["height"]
                    )
                    ims[storage_id]["resized_bitmap"][:, :, 3] = resized_bitmap * 255

                    ims[storage_id]["im"].set_data(ims[storage_id]["resized_bitmap"])
                    vlines[storage_id].set_xdata([timestep, timestep])

            vlines["global"].set_xdata([timestep, timestep])
            fig.canvas.draw_idle()

        slider.on_changed(update)

        slider.set_val(1)
        writer = FFMpegWriter(fps=60, bitrate=1800)
        writer.setup(fig, "test.mp4", dpi=100)
        for i in tqdm(range(self.time)):
            slider.set_val(slider.val + 1)
            writer.grab_frame()
        writer.finish()

        slider.set_val(1)
        plt.show()

    def _plot_fragmentation(self, axd) -> dict:
        """Plots the fragmentation data."""
        # Vertical lines that indicate the timestamp
        vlines = {}

        for storage_id in range(self.config.num_storage_ids):
            frag_ax = axd[f"frag_{storage_id}"]
            if self.config.blocks_of_storage_id(storage_id) != 0:
                # Extract fragmentation values from storage_frag
                frag_values = [frag for frag, _,
                               _ in self.storage_frag[storage_id]]
                frag_ax.plot(frag_values)
                frag_ax.set_xlim([0, self.time - 1])
                frag_ax.set_ylim([0, 1])
                frag_ax.set_xlabel("Timestamp")
                if storage_id == 0:
                    frag_ax.set_ylabel("Fragmentation")

                # Initial position at the end
                vlines[storage_id] = frag_ax.axvline(
                    x=self.time - 1,
                    color="red",
                    linestyle="--",
                    linewidth=1
                )
            else:
                kw = {"ha": "center", "va": "center", "fontsize": 12, "color": "darkgrey"}
                frag_ax.text(0.5, 0.5, "[Empty]", transform=frag_ax.transAxes, **kw)

        # Extract fragmentation values from global_frag
        global_frag_ax = axd["frag_global"]
        frag_values = [frag for frag, _, _ in self.global_frag]
        global_frag_ax.plot(frag_values)
        global_frag_ax.set_ylim([0, 1])
        global_frag_ax.set_xlim([0, self.time - 1])
        global_frag_ax.set_title("Global Fragmentation")
        global_frag_ax.set_xlabel("Timestamp")
        global_frag_ax.set_ylabel("Fragmentation")

        # Initial position at the end
        vlines["global"] = global_frag_ax.axvline(
            x=self.time - 1,
            color="red",
            linestyle="--",
            linewidth=1
        )

        return vlines

    def _color_disks(self, storage_bitmap: np.array, storage_id: int) -> np.ndarray:
        """Colors the disks within a storage differently."""
        colored_bitmap = np.zeros((len(storage_bitmap), 4), dtype=np.uint8)
        colored_bitmap[:, 3] = storage_bitmap
        for disk_id in range(self.config.disks_of_storage_id(storage_id)):
            start = self.disk_begins[storage_id][disk_id]
            end = start + self.config.blocks_of_disk(storage_id, disk_id)
            length = end - start

            color = id_to_color(disk_id)
            color_array = np.tile(color, (length, 1))

            colored_bitmap[start:end, 0:3] = color_array

        return colored_bitmap


color_mapping = [
    (0, 0, 0),
    (0, 0, 255),
    (0, 255, 0),
    (0, 255, 255),
    (255, 0, 0),
    (255, 0, 255),
    (255, 255, 0),
]


def id_to_color(i: int) -> tuple[int, int, int]:
    return color_mapping[i % len(color_mapping)]


def reshape_to_axes(arr: np.ndarray, ax, fig) -> np.ndarray:
    """
    Reshapes the first dimension of a NumPy array to a array with the first two
    dimensions close to the aspect ratio of the given Matplotlib axes.

    Args:
      arr_1d: The 1D NumPy array to reshape.
      ax: The Matplotlib axes object.
      fig: The Matplotlib figure object.

    Returns:
      A 2D NumPy array with dimensions close to the axes aspect ratio.
    """

    # Get axes dimensions in inches
    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())
    width, height = bbox.width, bbox.height

    # Calculate target aspect ratio
    target_aspect = width / height

    # Calculate the ideal number of columns for the target aspect ratio
    total_pixels = len(arr)
    cols = int(np.sqrt(total_pixels * target_aspect))

    # Adjust columns to find the closest aspect ratio while using all pixels
    rows = total_pixels // cols
    while rows * cols != total_pixels:
        cols -= 1
        rows = total_pixels // cols

    # Reshape the array to the calculated dimensions
    return arr.reshape(rows, cols, 4)


def reshape_to_close_aspect(arr_1d, width, height):
    """
    Reshapes a 1D NumPy array to a 2D array with dimensions close to the
    aspect ratio of the given width and height
    """
    rows, cols = get_close_aspect(width, height, len(arr_1d))

    # Reshape the 1D array to the calculated dimensions
    arr_2d = arr_1d.reshape(rows, cols)

    return arr_2d


@functools.lru_cache(128)
def get_close_aspect(width: int, height: int, length: int) -> tuple[int, int]:
    # Calculate target aspect ratio
    target_aspect = width / height

    # Calculate the ideal number of columns for the target aspect ratio
    total_pixels = length
    cols = int(np.sqrt(total_pixels * target_aspect))

    # Adjust columns to find the closest aspect ratio while using all pixels
    rows = total_pixels // cols
    while rows * cols != total_pixels:
        cols -= 1
        rows = total_pixels // cols

    return rows, cols


def fragmentation_of_bitmap(bitmap: np.array) -> tuple[float, int, int]:
    """Calculates the fragmentation of a bitmap."""
    if len(bitmap) == 0:
        return 0

    # total_free = len(np.where(bitmap == 0))
    total_free = np.count_nonzero(bitmap == 0)
    largest_free = longest_repeating_0s(bitmap)
    frag = calculate_fragmentation(total_free, largest_free)

    return frag, total_free, largest_free


def calculate_fragmentation(total_free: int, largest_free: int) -> float:
    if total_free == 0:
        return 0
    return 1 - (largest_free / total_free)


def longest_repeating_0s(arr: np.array) -> int:
    """
    Calculates the maximum consecutive count of 0s in a binary numpy array.

    Args:
      binary_array: A numpy array containing only 0s and 1s.

    Returns:
      Maximum consecutive count of 0s.
    """
    # Find indices where the array changes value
    indices = np.where(np.diff(arr))[0] + 1
    # Split the array at these indices
    splits = np.split(arr, indices)

    # Calculate lengths of splits and find maximum for 0
    return max([len(s) for s in splits if s[0] == 0], default=0)


def identify_axes(ax_dict, fontsize=24):
    kw = {"ha": "center", "va": "center", "fontsize": fontsize, "color": "darkgrey"}
    for k, ax in ax_dict.items():
        ax.text(0.5, 0.5, k, transform=ax.transAxes, **kw)


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Please provide a file to visualize!")
        sys.exit(1)
    log_file = sys.argv[1]

    config = parse_header(log_file)
    global_bitmap = GlobalBitMap(log_file, config)
    print(global_bitmap)

    global_bitmap.plot()
