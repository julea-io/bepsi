#!/usr/bin/env python3


import functools
from math import floor
import os
import struct
import sys
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, CheckButtons
import numpy as np
from tqdm import tqdm

# Constants to get relevant information from the disk_offset
MASK_STORAGE_CLASS = ((1 << 2) - 1) << (10 + 52)
MASK_DISK_ID = ((1 << 10) - 1) << 52
MASK_OFFSET = (1 << 52) - 1
SEGMENT_SIZE_LOG_2 = 18
SEGMENT_SIZE = 1 << SEGMENT_SIZE_LOG_2
SEGMENT_SIZE_MASK = SEGMENT_SIZE - 1
# This is the amount of bytes one (de-)allocation has in the log
SIZE_PER_ALLOCATION = 13


def parse_disk_offset(offset: int) -> (int, int, int):
    storage_class = (offset & MASK_STORAGE_CLASS) >> (52 + 10)
    disk_id = ((offset & MASK_DISK_ID) >> 52)
    block_offset = (offset & MASK_OFFSET)
    segment_id = (block_offset & ~SEGMENT_SIZE_MASK)
    return storage_class, disk_id, segment_id, block_offset


class Config:
    num_storage_ids: int
    disks_per_storage_id: list[int]
    blocks_per_disk: list[list[int]]
    blocks_per_segment: int

    def __init__(self, num_storage_ids: int,
                 disks_per_storage_id: list[int],
                 blocks_per_disk: list[list[int]],
                 blocks_per_segment: int,
                 ):
        self.num_storage_ids = num_storage_ids
        self.disks_per_storage_id = disks_per_storage_id
        self.blocks_per_disk = blocks_per_disk
        self.blocks_per_segment = blocks_per_segment

    def __str__(self) -> str:
        return f"num_storage_ids: {self.num_storage_ids}, \
        disks_per_class: {self.disks_per_storage_id}, \
        blocks_per_disk: {self.blocks_per_disk}, \
        blocks_per_segment: {self.blocks_per_segment}"

    def disks_of_storage_id(self, storage_id: int) -> int:
        return self.disks_per_storage_id[storage_id]

    def blocks_of_storage_id(self, storage_id: int) -> int:
        return sum(self.blocks_of_disk(storage_id, disk_id) for disk_id in range(self.disks_of_storage_id(storage_id)))

    def blocks_of_disk(self, storage_id: int, disk_id: int) -> int:
        return self.blocks_per_disk[storage_id][disk_id]


def parse_header(log_file: str) -> Config:
    """Parses the global header of the allocation log file."""

    with open(log_file, "rb") as f:
        num_classes = struct.unpack("<B", f.read(1))[0]
        disks_per_class = []
        for _ in range(num_classes):
            disks_per_class.append(struct.unpack("<H", f.read(2))[0])

        blocks_per_disk = []
        for i in range(num_classes):
            blocks_per_disk.append([])
            for _ in range(disks_per_class[i]):
                blocks_per_disk[i].append(
                    struct.unpack("<Q", f.read(8))[0])

        blocks_per_segment = struct.unpack("<Q", f.read(8))[0]

    return Config(num_classes,
                  disks_per_class,
                  blocks_per_disk,
                  blocks_per_segment)


def remaining_bytes(file_pointer) -> int:
    """Returns the remaining bytes in a file from the current position of the file pointer."""
    current_position = file_pointer.tell()
    file_pointer.seek(0, os.SEEK_END)  # Go to the end of the file
    end_position = file_pointer.tell()
    # Return to the original position
    file_pointer.seek(current_position, os.SEEK_SET)
    return end_position - current_position


class GlobalBitMap:
    config: Config
    # dict [ (storage, disk, segment), list[(time, bitmap)]]
    bitmap: dict[(int, int, int), list[(int, np.ndarray)]]
    log_file: str
    time: int = 0

    def __init__(self, log_file: str, config: Config):
        self.config = config
        self.log_file = log_file
        self._initialize_bitmap()
        self._build_global_bitmap()

    def __str__(self):
        return f"Log_file: {self.log_file}\n" + f"Time: {self.time}\n" + \
            f"Config: {self.config}\n"

    def _initialize_bitmap(self):
        self.bitmap = {}
        for storage_id in range(self.config.num_storage_ids):
            for disk_id in range(self.config.disks_of_storage_id(storage_id)):
                used_blocks = 0
                blocks_in_disk = self.config.blocks_of_disk(
                    storage_id, disk_id)
                while (used_blocks < blocks_in_disk):
                    segment_size = min(
                        self.config.blocks_per_segment, blocks_in_disk - used_blocks)

                    bitmap = np.packbits(np.zeros(segment_size, dtype=bool))
                    self.bitmap[(storage_id, disk_id, used_blocks)] = [
                        (0, bitmap)]
                    used_blocks += segment_size

    def _build_global_bitmap(self):
        """Builds a global bitmap representation for each time step."""
        with open(self.log_file, "rb") as f:
            # Skip the global header (already parsed)
            f.seek(1 + 2 * self.config.num_storage_ids + 8 *
                   sum(self.config.disks_per_storage_id) + 8)

            timesteps = remaining_bytes(f) // SIZE_PER_ALLOCATION

            i = 0
            # while True:
            for i in tqdm(range(timesteps), desc="Building bitmap"):
                # Read Allocation
                try:
                    op_type = struct.unpack("<B", f.read(1))[0]
                    offset = struct.unpack("<Q", f.read(8))[0]
                    num_blocks = struct.unpack("<L", f.read(4))[0]
                except struct.error:
                    break  # End of file

                self.time += 1

                storage_id, disk_id, segment_id, block_offset = parse_disk_offset(
                    offset)
                segment_offset = block_offset % self.config.blocks_per_segment

                # Update the bitmap at (storage_id, disk_id, segment_id) with
                # op_type at block_offset and size
                last_entry = self.bitmap[(storage_id, disk_id, segment_id)][-1]
                new_bitmap = np.unpackbits(last_entry[1]).copy()
                new_bitmap[segment_offset: segment_offset+num_blocks] = op_type
                new_bitmap = np.packbits(new_bitmap)
                self.bitmap[(storage_id, disk_id, segment_id)
                            ].append((self.time, new_bitmap))

    # Get the global bitmap at time. If no time is provided return the bitmap
    # of the last timestep.
    def get(self, time: int = None) -> np.array:
        if time is None or time > self.time:
            time = self.time
        if time < 0:
            raise IndexError("Time has to be non-negative")

        num_blocks = sum(sum(self.config.blocks_per_disk[storage_id]) for storage_id in range(
            self.config.num_storage_ids))
        bitmap = np.zeros(num_blocks, dtype=np.uint8)
        start = 0
        for storage_id in range(self.config.num_storage_ids):
            start += self.get_storage(bitmap[start:], storage_id, time)

        return bitmap

    # Get the bitmap of a storage id at time. If no time is provided return the
    # bitmap of the last timestep.
    # If it doesn't match with the config throw an errer
    def get_storage(self, output_bitmap: np.array, storage_id: int, time: int = None) -> int:
        if time is None or time > self.time:
            time = self.time
        if time < 0:
            raise IndexError("Time has to be non-negative")
        if storage_id >= self.config.num_storage_ids or storage_id < 0:
            raise IndexError(f"Tried to access storage with id {
                             storage_id} of 0-{self.config.num_storage_ids - 1}")
        if self.config.disks_of_storage_id(storage_id) == 0:
            return np.zeros(0)

        start = 0
        for disk_id in range(self.config.disks_of_storage_id(storage_id)):
            start += self.get_disk(
                output_bitmap[start:], storage_id, disk_id, time)

        return start

    def get_storage_bitmap(self, storage_id: int, time: int = None) -> np.array:
        num_blocks = self.config.blocks_of_storage_id(storage_id)
        bitmap = np.zeros(num_blocks, dtype=np.uint8)
        self.get_storage(bitmap, storage_id, time)
        return bitmap

    # Get the bitmap of a disk id at time. If no time is provided return the
    # bitmap of the last timestep.
    # If it doesn't match with the config throw an errer

    def get_disk(self, output_bitmap: np.array, storage_id: int, disk_id: int, time: int = None) -> int:
        if time is None or time > self.time:
            time = self.time
        if time < 0:
            raise IndexError("Time has to be non-negative")
        if storage_id >= self.config.num_storage_ids or storage_id < 0:
            raise IndexError(f"Tried to access storage with id {
                             storage_id} of 0-{self.config.num_storage_ids - 1}")
        if self.config.disks_of_storage_id(storage_id) == 0:
            return np.zeros(0)
        if disk_id >= self.config.disks_of_storage_id(storage_id) or disk_id < 0:
            raise IndexError(f"Tried to access disk with id {
                             disk_id} of 0-{self.config.disks_of_storage_id(storage_id) - 1}")

        blocks_per_segment = self.config.blocks_per_segment
        entries = filter(lambda k: k[0] ==
                         storage_id and k[1] == disk_id, self.bitmap)

        for entry in entries:
            segment_id = entry[2]
            time, bitmap_at_time = self._binary_search_time(
                time, entry)
            end = min(segment_id + blocks_per_segment,
                      self.config.blocks_of_disk(entry[0], entry[1]))

            output_bitmap[segment_id:end] = np.unpackbits(bitmap_at_time)

        return end

    def get_disk_bitmap(self, storage_id: int, disk_id: int, time: int = None) -> np.array:
        num_blocks = self.config.blocks_of_disk(storage_id, disk_id)
        bitmap = np.zeros(num_blocks, dtype=np.uint8)
        self.get_disk(bitmap, storage_id, disk_id, time)
        return bitmap

    @functools.lru_cache(1024)
    def _binary_search_time(self, time: int, entry: (int, int, int)) -> (int, np.array):
        bitmaps = self.bitmap[entry]
        left = 0
        right = len(bitmaps) - 1
        result = None
        while left <= right:
            middle = floor((left + right) / 2)
            if bitmaps[middle][0] == time:
                return bitmaps[middle]
            elif bitmaps[middle][0] < time:
                result = bitmaps[middle]
                left = middle + 1
            else:
                right = middle - 1

        return result

    def plot_simple(self):
        """Plots the bitmap with an interactive slider for timestamp selection."""

        fig, ax = plt.subplots()
        plt.subplots_adjust(bottom=0.25)

        # Initial plot (last timestamp)
        bitmap_np = self.get()

        # Calculate the size of the square
        size = int(np.ceil(bitmap_np.shape[0] ** 0.5))
        bitmap_square = np.pad(
            bitmap_np, (0, size * size - bitmap_np.shape[0]), "constant"
        ).reshape(size, size)
        im = ax.imshow(bitmap_square, cmap="gray_r", interpolation=None)
        ax.set_title(f"Timestamp: {self.time - 1}")
        ax.set_xlabel("Block")
        ax.set_ylabel("Block")
        ax.set_xticks([])
        ax.set_yticks([])

        # Create slider
        ax_slider = plt.axes([0.25, 0.1, 0.65, 0.03])
        slider = Slider(
            ax_slider,
            "Timestamp",
            0,
            self.time - 1,
            valinit=self.time - 1,
            valstep=1,
        )

        def update(val):
            timestamp = int(slider.val)
            bitmap_np = self.get(timestamp)

            # Calculate the size of the square
            size = int(np.ceil(bitmap_np.shape[0] ** 0.5))
            bitmap_square = np.pad(
                bitmap_np, (0, size * size - bitmap_np.shape[0]), "constant"
            ).reshape(size, size)

            im.set_data(bitmap_square)
            ax.set_title(f"Timestamp: {timestamp}")
            fig.canvas.draw_idle()

        slider.on_changed(update)
        plt.show()

    def plot(self):
        """Plots the bitmap with an interactive slider for timestamp selection and checkboxes for storage toggling."""
        form = [
            ["storage_0", "storage_1", "storage_2", "storage_3"],
            ["frag_0", "frag_1", "frag_2", "frag_3"],
            ["frag_global", "frag_global", "frag_global", "frag_global"],
            ["slider", "slider", "slider", "slider"],
        ]
        gs_kw = dict(width_ratios=[1, 1, 1, 1], height_ratios=[3, 1, 1, 0.03])
        fig, axd = plt.subplot_mosaic(
            form, gridspec_kw=gs_kw, layout="constrained")

        ims = {}
        # Initial plot (last timestamp)
        for storage_id in range(self.config.num_storage_ids):
            name = f"storage_{storage_id}"
            storage_bitmap = self.get_storage_bitmap(storage_id)
            resized_bitmap = reshape_to_axes(storage_bitmap, axd[name], fig)

            ims[name] = {}
            ims[name]["bm"] = storage_bitmap
            ims[name]["im"] = axd[name].imshow(
                resized_bitmap, cmap="gray_r", aspect="auto", interpolation=None)
            axd[name].set_title(f"Storage {storage_id}")
            axd[name].set_xlabel("Block")
            axd[name].set_ylabel("Block")
            axd[name].set_xticks([])
            axd[name].set_yticks([])

        slider = Slider(
            axd["slider"],
            "Timestamp",
            0,
            self.time - 1,
            valinit=self.time - 1,
            valstep=1,
        )

        def update(val):
            timestamp = int(slider.val)
            for storage_id in range(self.config.num_storage_ids):
                name = f"storage_{storage_id}"
                self.get_storage(ims[name]["bm"], storage_id, timestamp)
                resized_bitmap = reshape_to_axes(
                    ims[name]["bm"], axd[name], fig)

                ims[name]["im"].set_data(resized_bitmap)

            fig.canvas.draw_idle()

        # identify_axes(axd)
        slider.on_changed(update)
        plt.show()


def reshape_to_axes(arr_1d, ax, fig):
    """
    Reshapes a 1D NumPy array to a 2D array with dimensions close to the
    aspect ratio of the given Matplotlib axes.

    Args:
      arr_1d: The 1D NumPy array to reshape.
      ax: The Matplotlib axes object.
      fig: The Matplotlib figure object.

    Returns:
      A 2D NumPy array with dimensions close to the axes aspect ratio.
    """

    # Get axes dimensions in inches
    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())
    width, height = bbox.width, bbox.height

    # Calculate target aspect ratio
    target_aspect = width / height

    # Calculate the ideal number of columns for the target aspect ratio
    total_pixels = len(arr_1d)
    cols = int(np.sqrt(total_pixels * target_aspect))

    # Adjust columns to find the closest aspect ratio while using all pixels
    rows = total_pixels // cols
    while rows * cols != total_pixels:
        cols -= 1
        rows = total_pixels // cols

    # Reshape the 1D array to the calculated dimensions
    arr_2d = arr_1d.reshape(rows, cols)

    return arr_2d


def identify_axes(ax_dict, fontsize=24):
    kw = dict(ha="center", va="center", fontsize=fontsize, color="darkgrey")
    for k, ax in ax_dict.items():
        ax.text(0.5, 0.5, k, transform=ax.transAxes, **kw)


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Please provide a file to visualize!")
        exit(1)
    log_file = sys.argv[1]

    config = parse_header(log_file)
    global_bitmap = GlobalBitMap(log_file, config)
    print(global_bitmap)

    global_bitmap.plot_simple()
    global_bitmap.plot()
